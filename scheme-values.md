好的，遵照您的要求，我已经将这份计划书的核心从**测试闭包**修改为**测试Scheme的多返回值（Multiple Values）机制**。

以下是修改后的版本：

---

## Minischeme-MV: 极简多返回值测试语言 (v1.0)

### 1. 概述

这是一个为测试Scheme核心控制流特性——**多返回值**——而设计的极简方言。它剔除了分支、布尔值等复杂特性，只保留了实现和验证 `values` 与 `call-with-values` 机制所必需的纯粹元素：**整数、函数和列表**。

### 2. 核心原则

1.  **代码即数据**：代码结构就是抽象语法树（AST），极大简化了解析。
2.  **绝对极简**：语言只包含实现多返回值测试所必需的最小特性集，核心是 **`values`** 和 **`call-with-values`**。

### 3. 词法结构与数据类型

*   **括号 `()`**：用于构建列表（S-表达式）。
*   **符号**：由字母和数字组成的标识符（例如：`x`, `producer`）。
*   **数字**：仅支持整数（例如：`123`, `-45`）。

**基本数据类型**：
1.  **数字**：整数。
2.  **函数**：由 `lambda` 创建的闭包对象。
3.  **列表**：一个包含其他数据类型的有序集合。

### 4. 语法与语义

表达式分为三类：**特殊形式**、**多值处理形式** 和 **函数调用**。

#### 4.1 特殊形式

---

##### `define` (变量定义)

**作用**：在全局环境中创建一个变量绑定。
**语法**：`(define <name> <expression>)`

---

##### `lambda` (函数创建)

**作用**：创建一个匿名函数（闭包）。它会捕获当前的环境。
**语法**：`(lambda (<param1> ...) <body1> ...)`

---

##### `list` (列表创建)

**作用**：创建一个列表，用于辅助测试。
**语法**：`(list <expr1> <expr2> ...)`

---

#### 4.2 多值处理形式 (核心)

这是本语言的核心，用于测试多返回值的生产者-消费者模型。

##### `values` (多值生成)

**作用**：作为“生产者”的返回值，生成一个或多个值。
**语法**：`(values <expr1> <expr2> ...)`
**备注**：这个形式本身不直接返回值给用户，而是将其结果传递给一个期望多值的上下文，例如 `call-with-values`。

---

##### `call-with-values` (多值消费)

**作用**：连接一个**生产者**函数（返回多值）和一个**消费者**函数（接受这些值为参数）。
**语法**：`(call-with-values <producer> <consumer>)`

*   `<producer>`：必须是一个无参函数 `(lambda () ...)`，其函数体最后应调用 `values`。
*   `<consumer>`：是一个函数，其参数数量必须与 `<producer>` 生成的值的数量相匹配。

**求值规则**：
1.  首先，调用 `<producer>` 函数。
2.  `<producer>` 通过 `(values ...)` 指示它返回了多个值。
3.  然后，用 `<producer>` 返回的每一个值作为参数，按顺序调用 `<consumer>` 函数。
4.  整个 `call-with-values` 表达式的结果，就是 `<consumer>` 函数调用的结果。

---

#### 4.3 函数调用

**语法**：`(<operator> <operand1> ...)`

**内置函数**：
*   `+`：加法。`(+ 1 2 3)` => `6`
*   `-`：减法。`(- 10 3)` => `7`
*   `list-ref`：列表索引访问。`(list-ref (list 10 20) 1)` => `20`

---

### 5. 多返回值处理模型

Minischeme-MV 的核心是验证生产者-消费者模型。

*   **生产者 (Producer)**：一个通过 `(values ...)` 返回多个结果的函数。
*   **消费者 (Consumer)**：一个接收这些结果作为参数的函数。
*   **`call-with-values`** 是连接二者的桥梁。它确保了生产者在计算栈上留下的多个值，能够被正确地传递给消费者的参数列表，而不是被打包成一个单一的数据结构（如列表）。

在字节码层面，这通常通过一对专门的指令实现，例如 `RETURN_VALUES <n>` 和 `CALL_WITH_VALUES`，以在函数调用边界上传递这种多值状态。

---

### 6. 代码案例：测试多返回值操作

下面是一个完整的测试脚本，覆盖了多返回值的核心场景。

```scheme
;; 测试 1: 基本的多值生产与消费
;; 生产者返回 10 和 20，消费者接收它们并相加。
;; 预期结果: 30
(define test1
  (call-with-values
    (lambda () (values 10 20))
    (lambda (x y) (+ x y))))

;; 测试 2: 使用已定义的函数
;; 演示将 producer 和 consumer 分别定义。
(define producer (lambda () (values 5 3)))
(define consumer (lambda (a b) (- a b)))
;; 预期结果: 2
(define test2 (call-with-values producer consumer))

;; 测试 3: 单返回值情况
;; 当 (values ...) 只返回一个值时，其行为应类似于普通函数调用。
;; 预期结果: 100
(define test3
  (call-with-values
    (lambda () (values 100))
    (lambda (z) z)))

;; 测试 4: 零返回值情况
;; 生产者不返回值，消费者不接收参数。
;; 预期结果: 42
(define test4
  (call-with-values
    (lambda () (values))
    (lambda () 42)))

;; 测试 5: 消费者利用多值创建列表
;; 这是一个常见的用例：收集多个返回值到一个数据结构中。
;; 预期结果: 一个列表 '(3 4)
(define test5
  (call-with-values
    (lambda () (values 3 4))
    (lambda (x y) (list x y))))
```

### 7. 总结

这个 Minischeme-MV 语言通过聚焦于 `values` 和 `call-with-values`，提供了一个精确的测试环境，用于验证基于栈的编译器和虚拟机能否正确实现Scheme的多返回值传递契约。它移除了闭包测试的复杂性，使开发者可以专注于这一特定且关键的控制流机制。